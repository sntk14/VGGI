

// Vertex shader
const vertexShaderSource = `
attribute vec3 vertex;
attribute vec3 normal;
uniform mat4 ModelViewProjectionMatrix, normalMat;
uniform float shininess;
uniform vec4 lightColor;
uniform vec3 lightPosition;
uniform mat4 world;

varying vec3 v_normal;
varying vec3 light_pos;
varying vec4 color;
varying vec3 v_surfView;

void main() {
    v_normal = mat3(ModelViewProjectionMatrix) * normal;
    light_pos = lightPosition;
    color = lightColor;

    vec3 surfaceWPos = (world * vec4(vertex, 1.0)).xyz;
    v_surfView = lightPosition - surfaceWPos;
}`;


// Fragment shader
const fragmentShaderSource = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
   precision highp float;
#else
   precision mediump float;
#endif

varying vec4 color;
varying vec3 v_normal;
varying vec3 light_pos;
varying vec3 v_surfView;

void main() {
    vec3 normal = normalize(v_normal);
    vec3 surfLightVect = normalize(light_pos);
    vec3 surfViewDirection = normalize(v_surfView);
    vec3 cVector = normalize(surfLightVect + surfViewDirection);

    float shininess = 5.0;

    float innerLimit = cos(5.0 * 5.0 / 180.0);
    float outerLimit = cos(10.0 * 5.0 / 180.0);

    float inLight = smoothstep(outerLimit, innerLimit, surfLightVect);
    float light = inLight * dot(normal, surfLightVect);
    float specular = inLight * pow(dot(normal, cVector), shininess);

    gl_FragColor = color;
    gl_FragColor.rgb *= light;
    gl_FragColor.rgb += specular;
}`;